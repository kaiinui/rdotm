// Copyright (c) 2014 Soichiro Kashima
// Licensed under MIT license.

package main

import (
	"encoding/xml"
	"flag"
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"regexp"
)

const (
	OutputHeader = `// DO NOT EDIT.
// This file is automatically generated by rdotm tool.
// https://github.com/ksoichiro/rdotm

`
)

type Options struct {
	ResDir string
	OutDir string
	Class  string
	Clean  bool
}

type Resources struct {
	Strings []String `xml:"string"`
}

type String struct {
	Name  string `xml:"name,attr"`
	Value string `xml:",chardata"`
}

func main() {
	var (
		resDir = flag.String("res", "", "Resource(res) directory path. Required.")
		outDir = flag.String("out", "", "Output directory path. Required.")
		class  = flag.String("class", "R", "Class name to overwrite default value(R). Optional.")
		clean  = flag.Bool("clean", false, "Clean output directory before execution.")
	)
	flag.Parse()
	if *resDir == "" || *outDir == "" {
		flag.Usage()
		os.Exit(1)
	}

	parse(&Options{
		ResDir: *resDir,
		OutDir: *outDir,
		Class:  *class,
		Clean:  *clean})
}

func parse(opt *Options) {
	valuesDir := filepath.Join(opt.ResDir, "values")
	files, _ := ioutil.ReadDir(valuesDir)
	var res Resources
	for i := range files {
		entry := files[i]
		if matched, _ := regexp.MatchString(".xml$", entry.Name()); !matched {
			continue
		}
		entryPath := filepath.Join(valuesDir, entry.Name())
		r := parseXml(entryPath)
		if 0 < len(r.Strings) {
			res.Strings = append(res.Strings, r.Strings...)
		}
	}
	printAsObjectiveC(&res, opt)
}

func parseXml(filename string) (res Resources) {
	xmlFile, err := os.Open(filename)
	if err != nil {
		fmt.Println("Error opening file", err)
		return
	}
	defer xmlFile.Close()

	b, _ := ioutil.ReadAll(xmlFile)
	err = xml.Unmarshal(b, &res)
	if err != nil {
		fmt.Println("Error unmarshaling XML file", err)
		return
	}

	return res
}

func printAsObjectiveC(res *Resources, opt *Options) {
	// Create output directory
	if opt.Clean {
		os.RemoveAll(opt.OutDir)
	}
	os.MkdirAll(opt.OutDir, 0777)

	class := opt.Class

	// Print header file(.h)
	filename := filepath.Join(opt.OutDir, class+".h")
	f, _ := os.OpenFile(filename, os.O_RDWR|os.O_CREATE, 0666)
	defer f.Close()

	f.WriteString(OutputHeader)
	f.WriteString(fmt.Sprintf(`@interface %s : NSObject

`, class))
	for i := range res.Strings {
		s := res.Strings[i]
		f.WriteString(fmt.Sprintf("+ (NSString *)string_%s;\n", s.Name))
	}
	f.WriteString(`
@end
`)
	f.Close()

	// Print implementation file(.m)
	filename = filepath.Join(opt.OutDir, class+".m")
	f, _ = os.OpenFile(filename, os.O_RDWR|os.O_CREATE, 0666)
	defer f.Close()

	f.WriteString(OutputHeader)
	f.WriteString(fmt.Sprintf(`#import "%s.h"

@implementation %s

`, class, class))
	for i := range res.Strings {
		s := res.Strings[i]
		f.WriteString(fmt.Sprintf("+ (NSString *)string_%s { return @\"%s\"; }\n", s.Name, s.Value))
	}
	f.WriteString(`
@end
`)
	f.Close()
}
